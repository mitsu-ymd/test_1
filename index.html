<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Tetris</title>
<style>
body {
    background: #111;
    color: #fff;
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    margin-top: 20px;
}
#container {
    display: flex;
    gap: 20px;
}
canvas {
    background: #000;
    border: 2px solid #555;
}
.panel {
    font-size: 14px;
}
.panel h2 {
    margin: 5px 0;
}
</style>
</head>
<body>

<div id="container">
    <canvas id="game" width="300" height="600"></canvas>
    <div class="panel">
        <h2>Next</h2>
        <canvas id="next" width="120" height="120"></canvas>

        <h2>Hold</h2>
        <canvas id="hold" width="120" height="120"></canvas>

        <p>Score: <span id="score">0</span></p>
        <p>Level: <span id="level">1</span></p>
        <p>Lines: <span id="lines">0</span></p>
        <p>P: Pause<br>R: Restart</p>
    </div>
</div>

<script>
const COLS = 10;
const ROWS = 20;
const BLOCK = 30;

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const nextCanvas = document.getElementById("next");
const nextCtx = nextCanvas.getContext("2d");

const holdCanvas = document.getElementById("hold");
const holdCtx = holdCanvas.getContext("2d");

ctx.scale(BLOCK, BLOCK);
nextCtx.scale(30, 30);
holdCtx.scale(30, 30);

const COLORS = [
    null,
    "#00f0f0",
    "#0000f0",
    "#f0a000",
    "#f0f000",
    "#00f000",
    "#a000f0",
    "#f00000"
];

const SHAPES = [
    [],
    [[1,1,1,1]],
    [[2,0,0],[2,2,2]],
    [[0,0,3],[3,3,3]],
    [[4,4],[4,4]],
    [[0,5,5],[5,5,0]],
    [[0,6,0],[6,6,6]],
    [[7,7,0],[0,7,7]]
];

function createMatrix(w,h){
    return Array.from({length:h},()=>Array(w).fill(0));
}

let arena = createMatrix(COLS, ROWS);

function drawMatrix(matrix, offset, context){
    matrix.forEach((row,y)=>{
        row.forEach((value,x)=>{
            if(value){
                context.fillStyle = COLORS[value];
                context.fillRect(x+offset.x, y+offset.y,1,1);
            }
        });
    });
}

function collide(arena, player){
    for(let y=0;y<player.matrix.length;y++){
        for(let x=0;x<player.matrix[y].length;x++){
            if(player.matrix[y][x] &&
               (arena[y+player.pos.y] &&
                arena[y+player.pos.y][x+player.pos.x]) !== 0){
                return true;
            }
        }
    }
    return false;
}

function merge(arena, player){
    player.matrix.forEach((row,y)=>{
        row.forEach((value,x)=>{
            if(value){
                arena[y+player.pos.y][x+player.pos.x] = value;
            }
        });
    });
}

function rotate(matrix){
    return matrix[0].map((_,i)=>matrix.map(row=>row[i]).reverse());
}

function arenaSweep(){
    let rowCount = 0;
    outer: for(let y=arena.length-1;y>=0;y--){
        for(let x=0;x<COLS;x++){
            if(arena[y][x]===0){
                continue outer;
            }
        }
        arena.splice(y,1);
        arena.unshift(Array(COLS).fill(0));
        rowCount++;
        y++;
    }
    if(rowCount>0){
        player.lines += rowCount;
        player.score += [0,100,300,500,800][rowCount]*player.level;
        if(player.lines >= player.level*10){
            player.level++;
            dropInterval = Math.max(100, dropInterval-100);
        }
    }
}

function draw(){
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    drawMatrix(arena,{x:0,y:0},ctx);
    drawMatrix(player.matrix,player.pos,ctx);
}

function update(time=0){
    if(paused) return;
    const delta = time-lastTime;
    lastTime = time;
    dropCounter += delta;
    if(dropCounter>dropInterval){
        playerDrop();
    }
    draw();
    updatePanel();
    requestAnimationFrame(update);
}

function playerDrop(){
    player.pos.y++;
    if(collide(arena,player)){
        player.pos.y--;
        merge(arena,player);
        resetPlayer();
        arenaSweep();
    }
    dropCounter=0;
}

function resetPlayer(){
    player.matrix = nextPiece;
    nextPiece = randomPiece();
    player.pos.y=0;
    player.pos.x=(COLS/2|0)-(player.matrix[0].length/2|0);
    canHold = true;
    if(collide(arena,player)){
        arena = createMatrix(COLS,ROWS);
        player.score=0;
        player.level=1;
        player.lines=0;
    }
}

function randomPiece(){
    const type = Math.floor(Math.random()*7)+1;
    return SHAPES[type];
}

function updatePanel(){
    document.getElementById("score").textContent = player.score;
    document.getElementById("level").textContent = player.level;
    document.getElementById("lines").textContent = player.lines;
    drawSmall(nextCtx,nextPiece);
    drawSmall(holdCtx,holdPiece);
}

function drawSmall(ctx2,matrix){
    ctx2.clearRect(0,0,4,4);
    if(!matrix) return;
    matrix.forEach((row,y)=>{
        row.forEach((v,x)=>{
            if(v){
                ctx2.fillStyle=COLORS[v];
                ctx2.fillRect(x,y,1,1);
            }
        });
    });
}

let dropCounter=0;
let dropInterval=1000;
let lastTime=0;
let paused=false;

const player={
    pos:{x:0,y:0},
    matrix:null,
    score:0,
    level:1,
    lines:0
};

let nextPiece = randomPiece();
let holdPiece = null;
let canHold = true;

resetPlayer();
update();

document.addEventListener("keydown",e=>{
    if(e.key==="ArrowLeft"){
        player.pos.x--;
        if(collide(arena,player)) player.pos.x++;
    }else if(e.key==="ArrowRight"){
        player.pos.x++;
        if(collide(arena,player)) player.pos.x--;
    }else if(e.key==="ArrowDown"){
        playerDrop();
    }else if(e.key==="ArrowUp"){
        const rotated = rotate(player.matrix);
        const old = player.matrix;
        player.matrix = rotated;
        if(collide(arena,player)) player.matrix = old;
    }else if(e.code==="Space"){
        while(!collide(arena,player)) player.pos.y++;
        player.pos.y--;
        playerDrop();
    }else if(e.key==="p"||e.key==="P"){
        paused = !paused;
        if(!paused) update();
    }else if(e.key==="r"||e.key==="R"){
        arena = createMatrix(COLS,ROWS);
        player.score=0;
        player.level=1;
        player.lines=0;
    }else if(e.key==="c"||e.key==="C"){
        if(!canHold) return;
        const temp = holdPiece;
        holdPiece = player.matrix;
        player.matrix = temp || randomPiece();
        player.pos.y=0;
        player.pos.x=(COLS/2|0)-(player.matrix[0].length/2|0);
        canHold=false;
    }
});
</script>

</body>
</html>
